# **알고리즘**

- “컴퓨터를 활용한 문제 해결 과정에서 주어진 문제를 해결하는 일련의 방법 또는 절차이며, 문제해결 방법을 순서대로, 절차대로 나열한 것”

# **복잡도**

→ 알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도(complexity)라고 한다.

- **시간 복잡도(time complexity)**: 실행에 필요한 시간을 평가한 것
- **공간 복잡도(space complexity)**: 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것

## **시간복잡도**

컴퓨터 프로그래밍에서 시간복잡도가 가장 낮은 알고리즘을 채택하여 데이터를 효율적으로 관리한다. 예를 들어 택시를 타고 삼성역까지 가는 절차를 알고리즘이라고 하는데, 이때 수행하는 연산의 수를 시간복잡도로 나타낸다.

## **시간 복잡도 규칙**

1. 입력값(n)은 항상 0보다 크다.
2. 함수는 많은 입력값이 있을 때 더 많은 작업을 한다.
3. 시간 복잡도에서는 모든 상수를 삭제한다.
-> 만약 어떤 알고리즘의 복잡도가 3n 이라면 3은 고려하지 않고 복잡도는 n이 된다. 2n, 3n, 10n 모두 복잡도가 n 인 알고리즘이다.
4. 낮은 차수의 항들은 무시한다.
5. 시간 복잡도 함수가 log 함수를 포함할 경우 밑은 무시한다.
6. 등호를 사용하여 표현한다.
-> 2n 은 O(n) 과 같다. 여기서 O(n) 은 2n 이 어떤 함수의 집합에 속한다는 의미다. 2n = O(n), 2n ∈ O(n)

- **시간복잡도 1** : 입력 값(n)과 상관없이 일정한 시간이 걸림
- **시간복잡도 n** : 입력 값 (n)에 따라 시간도 (n) 만큼 비례하여 증가

![1.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/b58a4f18-b260-4542-91f1-0b82f5cbf5ff/1.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220702%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220702T064954Z&X-Amz-Expires=86400&X-Amz-Signature=e2f67d97caf0b810cf070f690b3a8fd0d2d47dad0cdb6fc65dc2050d6016503e&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%221.png%22&x-id=GetObject)

- n 값이 몇이든 한 번만 수행

![2.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/37960921-cbb3-42dd-8efa-7007594cf041/2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220702%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220702T065008Z&X-Amz-Expires=86400&X-Amz-Signature=3dcedad4dadd8779325d4717a1e8d24b00b1303084686590babbd4a29b47448e&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%222.png%22&x-id=GetObject)

- n 값에 따라 n만큼 반복.

![3.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/d5530a01-c0ec-4866-9e43-2d635805d439/3.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220702%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220702T065020Z&X-Amz-Expires=86400&X-Amz-Signature=efdac431d2bc827cc61a929799114bc77a7351be534c0524099c5351844b16d4&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%223.png%22&x-id=GetObject)

- 밖에 안에 똑같이 n번 만큼 실행.

![4.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/4500e893-b921-42a6-a25e-b100502d5cdd/4.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220702%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220702T065032Z&X-Amz-Expires=86400&X-Amz-Signature=8db5ac96f49334286658c03c9ead7781703e04d9151a8a6109677b562f1b2df7&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%224.png%22&x-id=GetObject)

- 점점 줄어듬.

# **알고리즘의 표현 방법**

### 1. 자연어

사람이 사용하는 국어나 영어와 같은 언어를 이용해 나타내는 방법

### 2. 순서도

주어진 문제를 해결하거나 업무를 처리할 때, 처리할 일의 순서를 한 단계씩 구분하여 약속된 도형으로 표현한 그림

![https://blog.kakaocdn.net/dn/cijwd5/btqVOrCTri7/jg2bGrYj005kgrnsIa7k7K/img.png](https://blog.kakaocdn.net/dn/cijwd5/btqVOrCTri7/jg2bGrYj005kgrnsIa7k7K/img.png)

### 3. 의사코드

자연어로 표현한 것을 연상 기호 등을 사용하여 쉽고 간단하게 문제의 처리 과정을 표현한 것

```java
A <- 1 // A에 1을 저장한다.
B <- 1 // B에 1을 저장한다.
SUM <- A+B // A와 B를 더한 것을 SUM에 저장한다.
if(A>B)
then print A //A가 B보다 크면 A를 출력한다.
else print "감자"//아니라면 "감자"를 출력한다.
```

### 4, 프로그래밍 언어

Java, C언어, C++ 등을 이용하여 나타낸 것

```java
public class Main  {
    public Main(){
        int a = 1;
        int b = 1;
        System.out.println(a);
        if(a > b){
            System.out.println(b);
        }
    }
    public static void main(String[] args) {
	// write your code here
    new Main();
    }
}
```

# **알고리즘 표기법**

![https://cphinf.pstatic.net/mooc/20210525_284/1621921589246JLuBn_PNG/mceclip0.png](https://cphinf.pstatic.net/mooc/20210525_284/1621921589246JLuBn_PNG/mceclip0.png)

- O (빅 오) : same or faster
- o (리틀 오) : faster
- θ (세타) : same rate
- Ω (빅 오메가) : same or slower
- ω (리틀 오메가) : slower

## **Big O (빅 오 표기법)**

- **시간**의 상한 (최악의 경우)
- 알고리즘의 성능 평가 방법 중 가장 많이 사용하는 방법 중 하나 ( 최악의 성능을 알 수 있다면, 적어도 이 정도의 성능은 보장한다는 뜻이므로)
- 여기서 O는 “on the order of”의 약자로, 쉽게 생각하면 “~만큼의 정도로 커지는” 것이라고 볼 수 있다.
- O(n)은 n만큼 커지는 것이므로 n이 늘어날수록 선형적으로 증가하게 된다.
- O(n/2)도 결국 n이 매우 커지면 1/2은 큰 의미가 없어지므로 O(n)이라고 볼 수 있다.

> 시간 복잡도를 나타낼 때는 모든 상수를 삭제한다. 만약 어떤 알고리즘의 복잡도가 3n 이라면 3은 고려하지 않고 복잡도는 n이 된다. 2n, 3n, 10n 모두 복잡도가 n 인 알고리즘이다.
또한 낮은 차수의 항이나, log 함수에서 밑은 무시한다.
> 

- 주로 아래 목록과 같은 Big O 표기가 실행 시간을 나타내기 위해 많이 사용된다. (소요 시간의 내림차순 / n^2 가 제일 오래 걸림 / **log 로그 -> 매번 무언가를 계속해서 절반으로 나누는 과정**)
    - **O(n^2) - 버블 정렬, 선택 정렬**
    - **O(n log n) - 병합 정렬**
    - **O(n) - 선형 검색**
    - **O(log n) - 이진 검색**
    - **O(1)**

## **Big Ω (빅 오메가 표기법)**

- **시간**의 하한 (최상의 경우)
- **Big O**가 알고리즘 실행 시간의 상한(**최악의 경우**)을 나타낸 것이라면, 반대로 **Big Ω**는 알고리즘 실행 시간의 하한(**최상의 경우**)을 나타낸다.
- 예를 들어 선형 검색에서는 n개의 항목이 있을때 최대 n번의 검색을 해야 하므로 상한이 O(n)이 되지만, 운이 좋다면 한 번만에 검색을 끝낼 수도 있으므로 하한은 Ω(1)이 된다.
- 아래 목록과 같은 Big Ω 표기가 많이 사용된다.
    - **Ω(n^2) - 선택 정렬**
    - **Ω(n log n) - 병합 정렬**
    - **Ω(n) - 버블 정렬**
    - **Ω(log n)**
    - **Ω(1) - 선형 검색, 이진 검색**

### ➕ 그 외 표기법

- **θ (빅 세타 표기법)**
    - 평균적인 경우, 딱 맞는 수행 시간
    - big-O 와 big-Omega 를 하나로 합쳐 표현한것과 같다.
- **o (리틀 오 표기법)** : 비교 대상인 그래프가 아래에 있을 때. 비교 대상인 다른 알고리즘보다 더 빠르다.
- **ω (리틀 오메가 표기법)** : 비교 대상인 그래프가 위에 있을 때. 비교 대상인 다른 알고리즘과 느리다.

→ 빅 오 표기법 = 주어진 문제를 해결하는 최악의 시간 파악하려고

→ 빅 오메가 표기법 = 주어진 문제를 해결하는 최상의 시간 파악하려고.

# **검색 알고리즘**

- 배열은 한 자료형의 여러 값들이 메모리상에 모여 있는 구조이다.
- 컴퓨터는 이 값들에 접근할 때 배열의 인덱스 하나하나를 접근한다.
- 어떤 값이 배열 안에 속해있는지 찾아 보기 위해서는 배열이 정렬되어 있는지에 따라 아래와 같은 방법을 사용할 수 있다.

## **선형 검색**

배열의 인덱스를 처음부터 끝까지 하나씩 증가 시키면서 방문하여 그 값이 속하는지를 확인한다.
배열의 길이가 n이라고 했을 때, 최악의 경우 배열의 모든 원소를 확인해야 하므로 n번만큼 실행해야 한다.
선형 검색은 **자료가 정렬되어 있지 않거나 그 어떤 정보도 없어 하나씩 찾아야 하는 경우에 유용**하다.

## **이진 검색**

만약 **배열이 정렬되어 있다면**, 배열 중간 인덱스 부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은(작은 값이 저장되어 있는) 인덱스 또는 큰(큰 값이 저장되어 있는) 인덱스 이동을 반복하면서 확인한다.

> **정렬은 시간이 오래 걸리고 공간을 더 차지한다. 하지만 이 추가적인 과정을 진행하면 여러 번 리스트를 검색해야 하거나, 매우 큰 리스트를 검색해야 할 경우 시간을 단축할 수 있게된다.**
> 

## **구조체**

- 예를 들어 names 배열에는 이름이, numbers 배열에는 전화번호가 들어있는 상황에서 이름을 조회하면 해당 이름이 갖는 전화번호 값이 리턴 되게 하고 싶다. 이때 각 배열에서 서로 같은 인덱스를 가져야 한다는 한계가 생긴다. 이를 해결하기 위해 **새로운 자료형으로 구조체를 정의해서 이름과 번호를 묶어**준다.
- person 이라는 이름의 구조체를 자료형으로 정의하고 person 자료형의 배열을 선언하면 그 안에 포함된 속성값은 ‘ . ’으로 연결해서 접근할 수 있다. 이렇게 함으로써 더욱 확장성 있는 프로그램을 만들 수 있다.

## **버블 정렬**

- 버블 정렬은 **두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬**하는 방법이다.
- 마치 거품이(비교 및 교환이) 터지면서 위로 올라오는(배열의 옆으로 이동하는) 방식이다.
- 버블 정렬은 **단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중**한다.
- 이 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있다.
**중첩 루프를 돌아야** 하고, n개의 값이 주어졌을 때 각 루프는 각각 n-1번, n-2번 반복 되므로
(n-1)*(n-2) = n^2-3n+2 번의 비교 및 교환이 필요한데, 여기서 가장 크기가 큰 요소는 n^2 이므로 위와 같은 코드로 작성한 **버블 정렬 실행 시간의 상한은 O(n^2)**이라고 말할 수 있다.
- 정렬이 되어 있는지 여부에 관계 없이 루프를 돌며 비교를 해야 하므로, 버블 정렬의 실행 시간의 하한도 여전히 Ω(n^2)이 된다.
- 그러나 만약 이미 정렬이 모두 되어 있다면 교환이 일어나지 않아도 된다. 그래서 **최종적으로 버블 정렬의 하한은 Ω(n)**이 된다.

## **선택 정렬**

- 선택정렬은 **배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식**이다.
- 선택 정렬은 **교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가**한다.
- 선택 정렬도 **두 번의 루프**를 돌아야 한다. 바깥 루프에서는 숫자들을 처음부터 순서대로 방문하고, 안쪽 루프에서는 가장 작은 값을 찾아야 한다.따라서 **소요 시간의 상한은 O(n^2)**이고, **하한도 마찬가지로 Ω(n^2)** 이다. **버블 정렬과 동일**하다.

## **병합 정렬**

- 병합 정렬은 **원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식**이다.
- 전화번호부의 분할 정복 탐색처럼 **데이터를 반으로 나누어간다**는 것과 공통점이 있다.
- **3단계**로 이루어진다. -> **1) 왼쪽 절반 정렬, 2) 오른쪽 절반 정렬, 3) 1,2를 정렬시키며 병합**
- **병합 정렬 실행 시간의 상한은 O(n log n)** 이다. 숫자들을 반으로 나누는 데는 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)의 시간이 걸리기 때문이다.
- **실행 시간의 하한도 역시 Ω(n log n)** 이다. 숫자들이 이미 정렬 되었는지 여부에 관계 없이 나누고 병합하는 과정이 필요하기 때문이다.

※ 참고 : 어떤 알고리즘의 상한선과 하한선이 같을 때는 Theta 표기법을 사용한다. (선택정렬, 병합정렬)

<aside>
💡 알고리즘을 만들 때 목표는 정확하게 만드는 것 뿐 아니라 잘 설계하는 것 !

</aside>
