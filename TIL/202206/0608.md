# 22/06/08
<aside>
💡 셀프 과제하는 날  >__<

</aside>

# To_do_list✔️



- [x]  부스트코스_알고리즘 듣기
- [x]  과제_01
- [x]  TIL



# 회고🤔

자바로 TV 클래스와 리모컨 클래스를 만들어 작동시켜 보는

셀프 과제를 마무리 했다.

추상화 개념과 인터페이스 개념을 천천히 이해 하면서

만들어 보았다.

예전에 비슷한 과제를 만들었을 땐 

상속과 오버라이딩 개념이 힘들어서 만드는데 어려움이 있었던 적이 있는데

다시 복습해보니까 또 이해가 됐다.

매일 매일 공부하면서 느끼는 거지만 

처음 볼 때 모른다고 실망할 필요 전~~~~혀 없다.

알고리즘도 하루에 하나씩 풀어보고 있는데,

슬슬 재밌다. 

[https://www.youtube.com/watch?v=ZZuD6iUe3Pc](https://www.youtube.com/watch?v=ZZuD6iUe3Pc) 이건 정렬 알고리즘 수행시간 비교 영상인데, 

이 영상을 보면서 느꼈다.

잘 짜여진 알고리즘은 프로그램 성능을 상당히 향상시킬 수 있을 것 같다.

좀 더 나은 프로그램을 만들 수 있게 항상 고민하는 자세를 가져야겠다.

1일 1알고리즘 실천하자!!

나는 어제보다 발전했고,

내일은 더 발전하는 앙응두가 될거다.

# [학습내용]



## **검색 알고리즘**

- 배열은 한 자료형의 여러 값들이 메모리상에 모여 있는 구조이다.
- 컴퓨터는 이 값들에 접근할 때 배열의 인덱스 하나하나를 접근한다.
- 어떤 값이 배열 안에 속해있는지 찾아 보기 위해서는 배열이 정렬되어 있는지에 따라 아래와 같은 방법을 사용할 수 있다.

## **선형 검색**

배열의 인덱스를 처음부터 끝까지 하나씩 증가 시키면서 방문하여 그 값이 속하는지를 확인한다.
배열의 길이가 n이라고 했을 때, 최악의 경우 배열의 모든 원소를 확인해야 하므로 n번만큼 실행해야 한다.
선형 검색은 **자료가 정렬되어 있지 않거나 그 어떤 정보도 없어 하나씩 찾아야 하는 경우에 유용**하다.

## **이진 검색**

만약 **배열이 정렬되어 있다면**, 배열 중간 인덱스 부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은(작은 값이 저장되어 있는) 인덱스 또는 큰(큰 값이 저장되어 있는) 인덱스 이동을 반복하면서 확인한다.

> **정렬은 시간이 오래 걸리고 공간을 더 차지한다. 하지만 이 추가적인 과정을 진행하면 여러 번 리스트를 검색해야 하거나, 매우 큰 리스트를 검색해야 할 경우 시간을 단축할 수 있게된다.**
> 

## **알고리즘 표기법**

## **Big O**

- 여기서 O는 “on the order of”의 약자로, 쉽게 생각하면 “~만큼의 정도로 커지는” 것이라고 볼 수 있다.
- O(n)은 n만큼 커지는 것이므로 n이 늘어날수록 선형적으로 증가하게 된다.
- O(n/2)도 결국 n이 매우 커지면 1/2은 큰 의미가 없어지므로 O(n)이라고 볼 수 있다.
    
    > 시간 복잡도를 나타낼 때는 모든 상수를 삭제한다. 만약 어떤 알고리즘의 복잡도가 3n 이라면 3은 고려하지 않고 복잡도는 n이 된다. 2n, 3n, 10n 모두 복잡도가 n 인 알고리즘이다.
    또한 낮은 차수의 항이나, log 함수에서 밑은 무시한다.
    > 
- 주로 아래 목록과 같은 Big O 표기가 실행 시간을 나타내기 위해 많이 사용된다. (소요 시간의 내림차순 / n^2 가 제일 오래 걸림 / **log 로그 -> 매번 무언가를 계속해서 절반으로 나누는 과정**)
    - **O(n^2) - 버블 정렬, 선택 정렬**
    - **O(n log n) - 병합 정렬**
    - **O(n) - 선형 검색**
    - **O(log n) - 이진 검색**
    - **O(1)**

## **Big Ω**

- **Big O**가 알고리즘 실행 시간의 상한(**최악의 경우**)을 나타낸 것이라면, 반대로 **Big Ω**는 알고리즘 실행 시간의 하한(**최상의 경우**)을 나타낸다.
- 예를 들어 선형 검색에서는 n개의 항목이 있을때 최대 n번의 검색을 해야 하므로 상한이 O(n)이 되지만, 운이 좋다면 한 번만에 검색을 끝낼 수도 있으므로 하한은 Ω(1)이 된다.
- 아래 목록과 같은 Big Ω 표기가 많이 사용된다.
    - **Ω(n^2) - 선택 정렬**
    - **Ω(n log n) - 병합 정렬**
    - **Ω(n) - 버블 정렬**
    - **Ω(log n)**
    - **Ω(1) - 선형 검색, 이진 검색**

## **구조체**

- 예를 들어 names 배열에는 이름이, numbers 배열에는 전화번호가 들어있는 상황에서 이름을 조회하면 해당 이름이 갖는 전화번호 값이 리턴 되게 하고 싶다. 이때 각 배열에서 서로 같은 인덱스를 가져야 한다는 한계가 생긴다. 이를 해결하기 위해 **새로운 자료형으로 구조체를 정의해서 이름과 번호를 묶어**준다.
- person 이라는 이름의 구조체를 자료형으로 정의하고 person 자료형의 배열을 선언하면 그 안에 포함된 속성값은 ‘ . ’으로 연결해서 접근할 수 있다. 이렇게 함으로써 더욱 확장성 있는 프로그램을 만들 수 있다.

## **버블 정렬**

- 버블 정렬은 **두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬**하는 방법이다.
- 마치 거품이(비교 및 교환이) 터지면서 위로 올라오는(배열의 옆으로 이동하는) 방식이다.
- 버블 정렬은 **단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중**한다.
- 이 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있다.
**중첩 루프를 돌아야** 하고, n개의 값이 주어졌을 때 각 루프는 각각 n-1번, n-2번 반복 되므로
(n-1)*(n-2) = n^2-3n+2 번의 비교 및 교환이 필요한데, 여기서 가장 크기가 큰 요소는 n^2 이므로 위와 같은 코드로 작성한 **버블 정렬 실행 시간의 상한은 O(n^2)**이라고 말할 수 있다.
- 정렬이 되어 있는지 여부에 관계 없이 루프를 돌며 비교를 해야 하므로, 버블 정렬의 실행 시간의 하한도 여전히 Ω(n^2)이 된다.
- 그러나 만약 이미 정렬이 모두 되어 있다면 교환이 일어나지 않아도 된다. 그래서 **최종적으로 버블 정렬의 하한은 Ω(n)**이 된다.

## **선택 정렬**

- 선택정렬은 **배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식**이다.
- 선택 정렬은 **교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가**한다.
- 선택 정렬도 **두 번의 루프**를 돌아야 한다. 바깥 루프에서는 숫자들을 처음부터 순서대로 방문하고, 안쪽 루프에서는 가장 작은 값을 찾아야 한다.따라서 **소요 시간의 상한은 O(n^2)**이고, **하한도 마찬가지로 Ω(n^2)** 이다. **버블 정렬과 동일**하다.

## **병합 정렬**

- 병합 정렬은 **원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식**이다.
- 전화번호부의 분할 정복 탐색처럼 **데이터를 반으로 나누어간다**는 것과 공통점이 있다.
- **3단계**로 이루어진다. -> **1) 왼쪽 절반 정렬, 2) 오른쪽 절반 정렬, 3) 1,2를 정렬시키며 병합**
- **병합 정렬 실행 시간의 상한은 O(n log n)** 이다. 숫자들을 반으로 나누는 데는 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)의 시간이 걸리기 때문이다.
- **실행 시간의 하한도 역시 Ω(n log n)** 이다. 숫자들이 이미 정렬 되었는지 여부에 관계 없이 나누고 병합하는 과정이 필요하기 때문이다.

※ 참고 : 어떤 알고리즘의 상한선과 하한선이 같을 때는 Theta 표기법을 사용한다. (선택정렬, 병합정렬)

<aside>
💡 **알고리즘을 만들 때 목표는 정확하게 만드는 것 뿐 아니라 잘 설계하는 것 !**

</aside>

빅 오 표기법 = 주어진 문제를 해결하는 최악의 시간 파악하려고

빅 오메가 표기법 = 주어진 문제를 해결하는 최상의 시간 파악하려고.

    
